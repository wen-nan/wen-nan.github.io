[{"categories":["算法学习"],"content":"算法学习之二分查找应用，学习LeetCode经典题目解题思路。","date":"2021-09-06","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/","tags":["二分查找","算法学习"],"title":"二分查找LeetCode题目应用","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/"},{"categories":["算法学习"],"content":"二分搜索问题泛化 把题目抽象出一个自变量x,一个关于x的函数f(x),以及一个目标值target。 同时，x,f(x),target必须满足以下条件： f(x)必须是在x上的单调函数。 题目是让计算满足约束条件f(x) == target时的x的值。 具体问题可以结合下面的图思考： 运用二分搜索解决具体的算法问题，可以从以下代码框架着手思考： 具体来说，可以总结为以下几步： 确定x，f(x)，target分别是什么，并写出函数f的代码。 找到x的取值范围作为二分搜索的搜索区间，初始化left和right变量。 根据题目要求，确定应该搜索左边界还是右边界，写出代码。 ","date":"2021-09-06","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/:1:0","tags":["二分查找","算法学习"],"title":"二分查找LeetCode题目应用","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/"},{"categories":["算法学习"],"content":"具体LeetCode题目应用 ","date":"2021-09-06","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/:2:0","tags":["二分查找","算法学习"],"title":"二分查找LeetCode题目应用","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/"},{"categories":["算法学习"],"content":"1、珂珂吃香蕉 本题中x就是吃香蕉的速度,target就是能吃完所有香蕉，f(x)可以定义为在速度x下能否吃完香蕉，**显然f(x)是单调递增的。**思考图像如下： 代码如下： func minEatingSpeed(piles []int, h int) int { // 二分查找左边界 maxSpeed := 0 for _, val := range piles { if val \u003e maxSpeed { maxSpeed = val } } left, right := 1, maxSpeed + 1 for left \u003c right { mid := left + (right - left) \u003e\u003e 1 if isEatFinish(piles, h, mid) == true { right = mid } else { left = mid + 1 } } return left } func isEatFinish(piles []int, h, speed int) bool { allTime := 0 for _, pile := range piles { if pile % speed == 0 { allTime += pile / speed } else { allTime += (pile / speed) + 1 } } return allTime \u003c= h } ","date":"2021-09-06","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/:2:1","tags":["二分查找","算法学习"],"title":"二分查找LeetCode题目应用","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/"},{"categories":["算法学习"],"content":"2、运送货物 题目与上一道类似，x就是船载货能力,target就是能载完货物，f(x)可以定义为在载货能力x下能否载完货物。不做具体分析，代码如下： func shipWithinDays(weights []int, days int) int { // 二分查找左边界 maxWeight, sum := 0, 0 for _, val := range weights { sum += val if val \u003e maxWeight { maxWeight = val } } left, right := maxWeight, sum + 1 for left \u003c right { mid := left + (right - left) \u003e\u003e 1 if isFinish(weights, days, mid) == true { right = mid } else { left = mid + 1 } } return left } func isFinish(weights []int, day, cap int) bool { allDay, sumWeight := 0, 0 for _, weight := range weights { if sumWeight + weight \u003c= cap { sumWeight += weight } else { sumWeight = weight allDay++ } } allDay++ return allDay \u003c= day } ","date":"2021-09-06","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/:2:2","tags":["二分查找","算法学习"],"title":"二分查找LeetCode题目应用","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/"},{"categories":["算法学习"],"content":"3、分隔数组的最大值 ","date":"2021-09-06","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/:2:3","tags":["二分查找","算法学习"],"title":"二分查找LeetCode题目应用","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E5%BA%94%E7%94%A8/"},{"categories":["算法学习"],"content":"算法学习之二分查找，主要学习二分查找几种常见用法。","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":" 注意：排序数组中的搜索问题，首先想到二分法。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:0:0","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"一、基本的二分查找 最简单的情况就是搜索一个数，如果存在，返回索引；否则返回-1。 func search(nums []int, target int) int { // 二分查找 left, right := 0, len(nums) - 1 // 注意 for left \u003c= right { mid := left + (right - left) \u003e\u003e 1 // 注意 if nums[mid] == target { return mid } else if nums[mid] \u003e target { right = mid - 1 // 注意 } else if nums[mid] \u003c target { left = mid + 1 // 注意 } } return -1 } ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:0","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"mid防止溢出 代码mid := left + (right - left) \u003e\u003e 1目的是为了防止left和right太大相加导致溢出。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:1","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"循环结束条件 循环结束条件是\u003c=，而不是\u003c。 是因为初始化right的赋值是nums.length - 1，即最后一个元素的索引，而不是nums.length。两者出现在不同功能的二分查找中，区别是：前者相当于两端都是闭区间[left, right]，后者相当于左闭右开区间[left, right)。我们可以把这个区间称作搜索区间。而搜索未找到停止搜索的条件就是搜索区间为空。当left == right时，搜索区间还有一个值。所以循环结束条件是\u003c=。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:2","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"left、right每次迭代更替的值 此处是left = mid + 1, right = mid - 1,有时候是right = mid或者left = mid。为什么呢？ 当我们理解搜索区间的概念后，本算法中搜索区间两端都是闭的。当发现索引mid不是要找的target时，下一步的搜索区间应该是[left, mid - 1]或者[mid + 1, right]。因为mid已经搜索过，应该从搜索区间中去除。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:1:3","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"二、搜索左边界 常见代码如下： func search(nums []int, target int) int { if len(nums) == 0 { return -1 } left, right := 0, len(nums) // 注意 for left \u003c right { //注意 mid := left + (right - left) \u003e\u003e 1 if nums[mid] == target { right = mid } else if nums[mid] \u003e target { right = mid // 注意 } else if nums[mid] \u003c target { left = mid + 1 } } return left } ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:0","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"循环结束条件 此处终止条件是left \u003c right。是因为前面right = nums.length，所以搜索区间是[left, right)左闭右开。所以循环的终止条件等价于left == right，此时搜索区间已经为空，可以终止。 注意：至于为什么这里写成左闭右开搜索区间形式，是因为这种写法较为普遍。也可以赋值为right = nums.length - 1写为闭区间。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:1","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"返回值解惑 为什么没有返回-1操作？如果nums中不存在target这个值，怎么办？ 先理解左侧边界有什么特殊含义： 对于上述数组，算反会返回1。这个1的含义可以解读为：nums中小于2的元素有1个。 比如对于有序数组nums = [2,3,5,7],target = 1，算法会返回0，含义是：nums中小于1的元素有0个。 再比如说nums = [2,3,5,7],target = 8，算法会返回4，含义是：nums中小于8的元素有4个。 可以看出，函数返回值（即left变量的值）取值区间是闭区间[0, nums.length]。所以我们可以在循环结束后面添加如下代码，就能在正确的时候返回-1: for left \u003c right { // ... } // target 比所有数都大 if left == len(nums) { return -1 } // 处理其他情况 if nums[left] == target { return left } else { return -1 } 为什么返回left而不是right? 因为循环终止条件是left == right，所以都是一样的。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:2","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"left、right每次迭代更替的值 此处right = mid， left = mid + 1是因为搜索区间是[left, right)左闭右开，所以当nums[mid]被检测之后，下一步搜索区间应该去掉mid分隔为两个区间，即[left, mid)和[mid + 1, right)。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:3","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"为什么能搜索左侧区间？ 关键在于对nums[mid] == target这种情况的处理： 找到target时不立即返回，而是缩小搜索区间的上届right，在区间[left, mid)中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:2:4","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"三、搜索右边界 和搜索左边界类似，依然采用左闭右开搜索区间的写法，有两处不同已标注： func search(nums []int, target int) int { if len(nums) == 0 { return -1 } left, right := 0, len(nums) for left \u003c right { mid := left + (right - left) \u003e\u003e 1 if nums[mid] == target { left = mid + 1 // 注意 } else if nums[mid] \u003e target { right = mid } else if nums[mid] \u003c target { left = mid + 1 } } return left - 1 // 注意 } ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:0","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"为什么能搜索右侧区间？ 类似的，关键点在于： 当nums[mid] == target时，不要立即返回，而是增大搜索区间的下界left,使得区间不断向右收缩，达到锁定右侧边界的目的。 ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:1","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["算法学习"],"content":"返回值解惑 为什么最后返回left - 1而不像左侧边界的函数，返回left？而且我觉得这里既然是搜索右侧边界，应该返回right才对。 因为循环终止条件是left == right,所以left和right是一样的。 至于为什么要减一，是搜索右侧边界的一个特殊点，关键在这个条件判断： 因为我们对left的更新必须是left = mid + 1，而循环结束时，nums[left]一定不等于target了，而nums[left - 1]可能是target。 为什么没有返回-1操作？如果nums中不存在target这个值，怎么办？ 类似搜索左边界，left的取值范围是[0, nums;length]，所以添加如下代码，可以正确返回-1: for left \u003c right { // ... } // target 比所有数都小 if left == 0 { return -1 } // 处理其他情况 if nums[left - 1] == target { return left - 1 } else { return -1 } ","date":"2021-09-04","objectID":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/:3:2","tags":["二分查找","算法学习"],"title":"二分查找","uri":"/posts/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"},{"categories":["Git"],"content":"学习Git命令行的基本使用。","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"一、Git简介 Git是分布式版本控制系统。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:1:0","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"集中式VS分布式 集中式版本控制系统，版本库集中存放在中央服务器，干活的时候先从中央服务器获取最新版本；干完活再把更新推送到中央服务器。最大缺点就是必须联网才能工作。 分布式版本控制系统，没有”中央服务器“，每个人的电脑都是一个完整地版本库。 实际使用分布式版本控制系统的时候，很少在两个个人电脑之间推送版本修改。通常也有一台充当”中央服务器“的电脑，作用是方便”交换“大家的修改。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:1:1","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"二、使用Git 安装完Git后，需要设置名字和email git config --global user.name \"your name\" git config --global user.email \"email@example.com\" 注意--global参数，表示这台计算机上所有Git仓库都使用这个配置。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:0","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"创建版本库 在相应目录下使用git init命令即可把这个目录变成Git可以管理的仓库。这样目录下会多出一个.git的目录，用来跟踪管理版本库的。 将文件添加到暂存区： git add [file1] [file2] ... 添加一个或多个文件到暂存区 git add [dir] 添加指定目录(包括子目录)到暂存区 git add .添加当前目录下所有文件到暂存区 将暂存区文件提交到仓库： git commit -m [message] 提交暂存区到本地仓库，message可以是一些备注信息 git commit [file1] [file2] ... -m [message] 提交指定文件 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:1","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"远程仓库使用 首先在GitHub上创建一个仓库，然后将本地仓库与远程仓库关联，最后可以把本地仓库内容推送到GitHub仓库。 关联远程仓库GitHub git remote add origin https://github.com/用户名/github远程仓库名 添加后，远程仓库名字就是origin,这个名字是Git默认叫法，可以更改 git remote -v显示所有远程仓库 git remote show [remote]显示某个远程仓库的信息 git remote rm name删除远程仓库 git remote rename old_name new_name修改仓库名 把本地仓库内容推送到远程仓库 git push -u origin master把当前分支master推送到远程，第一次推送需要加-u参数，此时Git不但会把本地master分支内容推送到远程新的master分支，还会把两者关联起来，后续推送或拉取可以简化命令。 git push \u003c远程仓库名\u003e \u003c本地分支名\u003e:\u003c远程分支名\u003e如果本地分支名和远程分支名相同，则可以简写git push \u003c远程仓库名\u003e \u003c本地分支名\u003e 从远程仓库克隆 git clone -b 分支名 [url] [name]默认情况下，Git会按照提供的url所指向的项目名称创建本地项目目录，但也可以修改项目名称([name]中修改，默认的话不写)。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:2:2","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"三、仓库管理 查看仓库当前状态，显示有变更的文件 git status 查看挡墙仓库状态，输出的命令很详细，但有些繁琐 git status -s获取简短的输出结果 新添加的未跟踪文件前面有??标记 新添加到暂存区中的文件前面有A标记 修改过的文件前面有M标记，出现在右边的M表示文件被修改了但是还没放入暂存区，出现在靠左边表示文件被修改了并放入了暂存区。 比较文件的不同 git diff [file] 显示暂存区和工作区的差异 git diff --cached [file] 显示暂存区和上一次提交到仓库的文件的差异 注意：比较后按q退出 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:3:0","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"版本回退 查看历史提交记录 git log ,--oneline选项来查看历史记录的简介版本 git blame \u003cfile\u003e查看自定文件的修改记录 回退版本 git reset [--soft | --mixed | --hard] [HEAD] 注意：HEAD表示当前版本，HEAD~1表示上一个版本，以此类推。 可以使用git reflog查看命令历史。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:3:1","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"工作区/暂存区/本地仓库 工作区(working directory):就是电脑能看到的目录 版本库(repository):工作区有一个隐藏目录.git，就是Git版本库。Git的版本库存放了很多东西，最重要的是stage的暂存区，还有Git为我们自动创建的第一个分支master,以及指向master的一个指针叫HEAD。 Git常用的六个命令：git clone、git push、git add 、git commit、git chechout、git pull如下： 注意：Git管理的是修改，而不是管理的文件。 我们对一个文件进行以下操作：第一次修改-\u003egit add-\u003e第二次修改-\u003egit commit。可以发现只有第一次修改被提交了，第二次修改没有被提交。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:3:2","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"撤销修改 如果修改了工作区某个文件，还没添加到缓存区，想直接丢弃工作区修改时，用命令git checkout -- file。 注意：--很重要，没有就会变成”切换到另一个分支“的命令。 如果修改了工作区某个文件，还添加到了暂存区，想丢弃修改，分两步：第一步用git reset HEAD \u003cfile\u003e回到上一个情景，然后使用上一个情景的操作。 如果修改后已经提交到了本地仓库，想撤销本次提交，采用版本回退。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:3:3","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"删除文件 如果工作区和本地仓库同步的时候，删除了工作区某个文件，git status可以看到哪些文件被删除了。此时有两个选择： 确实要从版本库中删除该文件，就用git rm命令删除，并且git commit,这样文件就从版本库中删除了。 git rm \u003cfile\u003e将从工作区和暂存区中删除文件。如果删除之前修改过并且已经放到了暂存区，则必须用强制删除选项-f。 另一种情况就是删错了，版本库里面还有，所以可以轻松把误删文件恢复到最新版本。 使用命令git checkout -- \u003cfile\u003e。但是这种方式会丢失最近一次提交后你修改的内容。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:3:4","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"四、分支管理 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:4:0","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"创建与合并分支 在Git里，主分支是master，严格来说HEAD指向当前分支，然后master才指向提交。 当我们创建新分支时，例如dev,Git新建了一个指针叫dev,指向master相同的提交，再把HEAD指向dev，就表示当前分支在dev上： **现在开始，对工作区的修改和提交就针对dev分支了，**比如新提交一次，dev指针往前移动一步，而master指针不变： 在dev分支上得工作完成了，就可以把dev合并到master上，最简单的方式就是直接把master指向dev的当前提交，就完成了合并： 合并完成后，可以删除dev分支。删除分支就是把对应指针删除掉。 命令实现 创建、切换分支 git branch \u003cname\u003e创建分支 git branch 查看分支(会列出所有分支，当前分支前面会标*号) git checkout \u003cname\u003e或者git switch \u003cname\u003e切换分支 git checkout -b \u003cname\u003e或者git switch -c \u003cname\u003e 创建并切换分支 推荐使用git switch命令 合并分支 git merge \u003cname\u003e合并某指定分支到当前分支 但如果两个分支各自有自己的提交，Git无法自动合并分支时，必须首先解决冲突。 解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。 通常，合并分支时，如果可能Git会用Fast forward模式。但这样删除分支后，会丢掉分支信息，使用--no-ff会强制禁用Fast forward模式 git merge --no-ff -m [描述] \u003cname\u003e因为本次合并要创建新的commit,所以要加上-m参数，把commit描述写上去。 删除分支 git branch -d \u003cname\u003e删除指定分支 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:4:1","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"多人协作 多人协作时，大家都会向分支上推送各自的修改，这时**会出现远程分支比本地更新，就需要先用git pull抓取远程新提交并试图合并。**如果有冲突，要先处理冲突。 命令格式如下： git pull -rebase \u003c远程主机名\u003e \u003c远程分支名\u003e:\u003c本地分支名\u003e如果远程分支与当前分支合并，则冒号后面的部分可以省略不写。 注意：rebase操作可以把本地未push的分叉提交历史整理成直线，目的是使得我们在查看历史提交的变化时更容易。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:4:2","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"五、标签管理 标签(tag)就是一个让人容易记住的有意义的名字，他跟某个commit绑定在一起。如果这个commit即出现在master分支上，又出现在dev分支，那么在这两个分支上都可以看到这个标签。 命令git tag \u003ctagname\u003e用于新建一个标签，默认为HEAD，也可以指定一个commit id。 命令git tag -a \u003ctagname\u003e -m \"blabla...\"可以指定标签信息。 命令git tag可以查看所有标签。 删除标签 git tag -d \u003ctagname\u003e可以删除一个本地标签 git push origin \u003ctagname\u003e可以推送一个本地标签到远程仓库 git push origin --tags推送全部未推送的标签到远程仓库 git push origin :refs/tags/\u003ctagname\u003e删除远程仓库中某一个标签 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:5:0","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"六、特殊使用 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:6:0","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Git"],"content":"忽略特殊文件 有时候需要忽略Git工作目录中的一些文件，但每次git status时都会显示Untracked files...，可以使用对应方法解决。在Git工作区的根目录下创建一个特殊的.gitignore文件，然后把要忽略的文件名填进去，Git则会自动忽视这些文件。 GitHub提供了各种配置文件的模板，可以任意组合使用。https://github.com/github/gitignore .gitignore文件本身要放到版本库里，并且可以对.gitignore做版本管理。 ","date":"2021-09-03","objectID":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/:6:1","tags":["Git"],"title":"Git基础使用","uri":"/posts/git%E5%9F%BA%E7%A1%80%E4%BD%BF%E7%94%A8/"},{"categories":["Golang学习"],"content":"学习Go语言中比较细枝末节的语法细节。","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"一、类型 简短模式(x := 100)定义限制: 定义变量，同时显示初始化。 不能提供数据类型。 只能用在函数内部。 简短模式有可能会出现退化的赋值操作。例如： 退化赋值前提条件：最少有一个新变量被定义，且必须是同一作用域 编译器将未使用的局部变量当做错误，全局变量没问题，局部常量const y = 123也没问题,可指定常量类型或由编译器推断,const y int = 123 符号名字首字母大小写决定了其作用域。首字母大写为导出成员，可被包外引用。 Go并没有明确意义上的枚举(enum)定义，不过可以借助itoa标识符实现一组自增常量值来实现枚举类型。 自定义数据类型(type)中,type data int不能理解为取别名，这只能表明它们有相同底层数据结构，两者间不存在任何关系，属于完全不同的两种类型，不能隐式转换，也不能直接用于比较表达式。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:1:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"二、表达式 自增、自减不再是运算符。只能作为独立语句，不能用于表达式。 局部变量的有效范围包含整个if/else块， 编程细节：尽可能减少代码块嵌套，让正常逻辑处于相同层次。将流程和局部细节分离是常见做法，不同的变化因素被分隔在各自独立单元(函数或模块)内，可避免修改时造成关联错误，减少患”肥胖症“的函数数量。 该示例中，if块显然承担了两种逻辑：错误处理和后续正常操作。 如此，if块仅完成条件检查和错误处理，相关正常逻辑保持在同一层次。 switch语句中，无须显示执行break语句，case执行完毕后自动中断。如须贯通后续case，须执行fallthrough，但不再匹配后续条件表达式。注意，fallthrough必须放在case块末尾，可使用break语句阻止。 无论普通的for循环，还是range迭代，其定义的局部变量都会重复使用。 注意：range会复制目标数据。 相关数据类型中，复制成本都很小，无须专门优化。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:2:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"三、函数 不管是指针、应用类型，还是其他类型参数，都是值拷贝传递。区别无非是拷贝目标对象还是拷贝指针而已。 如果函数参数过多，建议将其重构为一个符合结构类型，也算变相实现可选参数和命名实参功能。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:3:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"闭包 闭包是函数和引用环境的组合体。关键要分析出返回函数引用到哪些变量。 正因为闭包通过指针引用环境变量，那么可能会导致其生命周期延长，甚至被分配到堆内存。另外，还有所谓\"延迟求值\"的特性。 由于for循环复用局部变量i，则每次添加匿名函数引用的自然是同一变量。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:3:1","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"错误 Go的错误处理方式存在不足，即大量函数和方法返回error，使得调用代码变得很难看，一堆堆的检查语句充斥在代码行间。解决思路有： ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:3:2","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"四、数据 要修改字符串，须将其转换为可变类型([]byte或[]rune)，待完成后再转换回来。但不管如何转换，都须重新分配内存，并复制数据。 数组中，元素类型相同，长度不同的数组不属于同一类型。 与C不同，Go数组是值类型，赋值和传参操作都会复制整个数组数据，可以改用指针或切片，避免数据复制。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:4:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"切片 可基于数组来创建切片，注意cap的计算方式cap = max - low，结合下图理解： 属性cap表示切片所引用数组片段的真实长度，len用于限定可读的写元素数量。 使用append追加元素时，数据被追加到原底层数组。如果超出cap限制，则为新切片对象重新分配数组。注意：1.是超出切片cap限制，而非底层数组长度限制，因为cap可小于数组长度。2.新分配数组长度是原cap的2倍，而非原数组的2倍，并且非总是2倍，较大的切片会尝试扩容1/4,以节约内存。 注意：切片初始化使用make函数时，若不指定cap,则cap和len一样。 利用上述特性，可以容易实现一个栈式数据结构,很巧妙，可以学习使用 编程技巧：1.正是因为存在重新分配底层数组的缘故，某些场合建议多预留足够的空间，避免中途内存分配和数据复制开销。2.如果切片长时间引用大数组中很小的片段，建议新建独立切片，复制出所需数据，以便原数组内存可被及时回收。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:4:1","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"字典 因为内存访问安全和哈希算法的缘故，字典被设计成\"not addresssable\",故不能直接修改value成员(结构或数组)。例如m[1].age += 1 正确做法是返回整个value，待修改后再设置字典键值，或直接用指针类型。 运行时会对字典并发操作做出检测，可使用sync.RWMutex实现同步，避免读写操作同时进行。 字典对象本身就是指针包装，传参时无须再次取地址；在创建时预先准备足够空间有助于提升性能，减少扩张时的内存分配和重新哈希操作。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:4:2","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"结构 空结构可作为通道元素类型，用于事件通知。 实际上，这类**“长度\"为零的对象通常都指向runtime.zerobase变量**。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:4:3","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"五、方法 方法内部不引用实例，则可省略参数名，仅保留类型。 类型T和类型*T的方法集不相同，具体关系如下： 可以像访问匿名字段成员那样调用其方法 很显然，匿名字段就是为方法准备的。Go语言更加倾向于\"组合优于继承\"的思想将模块分解成相互独立的更小单元，分别处理不同方面的需求，最后以匿名嵌入的方式组合到一起。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:5:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"六、接口 Go接口实现机制很简洁，只要目标类型方法集内包含接口声明的全部方法，就被视为实现了接口，无须作显示声明。当然，目标类型可以实现多个接口。但是接口会有一些语法限制。 接口通常以er作为名称后缀，方法名是声明组成部分，但参数名可不同或省略。 超集接口变量可隐式转换为子集，反过来不行。 将对象赋值给接口变量时，会复制该对象。**甚至无法修改接口存储的复制品，**即便将其复制出来，用本地变量修改后，依然无法对iface.data赋值。解决方法是将对象指针赋值给接口。 只有当接口变量内部的两个指针(itab,data)都为nil时，接口才等于nil。itab中还存放了接口类型的字段。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:6:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"七、并发 并发和并行的区别，简单地说，并行是并发设计的理想执行模式。 并发：逻辑上具备同时处理多个任务的能力。 并行：物理上在同一时刻执行多个并发任务。 与defer一样，goroutine也会因“延迟执行”而立即计算并复制执行参数。进程退出时不会等待并发任务结束，可用通道(channel)阻塞，然后发出退出信号。 **如果等待多个任务结束，推荐使用sync.WaitGroup。**通过设定计数器，让每个goroutine在退出前递减，直至归零时解除阻塞。 注意：尽管WaitGroup.Add实现了原子操作，但还是建议在goroutine外累加计数器，避免Add尚未执行，Wait已经退出。 通常使用工厂方法将goroutine和通道绑定 通道可能会引发资源泄露(goroutine leak),确切的说，是指goroutine处于发送或接收阻塞状态，但一直未被唤醒。垃圾回收器并不收集此类资源，导致它们会在等待队列里长久休眠，形成资源泄露。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:7:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"八、包结构 编译器等相关工具按GOPATH设置的路径搜索目标，即在导入目标库时，排在列表前面的路径比当前工作空间优先级更高。 注意：不同操作系统，GOPATH列表分隔符不同。UNIX-like使用冒号，Windows使用分号。 同一目录下所有源码文件必须使用相同包名称，不能把多个包放到同一个目录中，也不能把同一个包的文件分拆到多个不同目录中。不同路径的同名包允许存在，可以利用后面给包取别名来区分。 程序编译时，会使用声明main包的代码所在的目录的目录名作为二进制可执行文件的文件名(如果编译时不给出编译后的可执行文件名)。 编译器首先确保完成所有全局变量初始化，然后才开始执行初始化函数。直到这些全部结束后，运行时才正式进入main.main入口函数。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:8:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"GOPATH模式 通过输入go env命令，可以看到GOPATH变量的结果，GOPATH目录下一共包含了三个子目录，分别是： bin:存储所编译生成的二进制文件。 pkg:存储预编译的目录文件，以加快程序的后续编译速度。 src:存储所有.go文件或源代码。 因此在使用GOPATH模式下，我们需要把应用代码存放在固定的$GOPATH/src目录下，并且如果执行go get来拉取外部依赖会自动下载并安装到$GOPATH目录下。 弃用GOPATH模式 GOPATH模式下没有版本控制的概念，在执行go get的时候，你无法传达任何版本信息，也就是说你无法知道自己当前跟新的是哪一个版本，也无法通过指定具体版本。 运行Go应用程序时，无法保证其他人与你所期望依赖的第三方库是相同的版本。 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:8:1","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"Go Modules模式 提供了如下命令进行操作： 提供的环境变量 GO111MODULE 这个环境变量作为Go modules的开关，允许设置一下参数： auto:只要项目包含go.mod文件的话启动Go modules。 on:启动Go modules。 off:禁用Go modules。 GOPROXY 这个环境变量主要是用于设置Go模块代理，作用是用于使Go在后续拉取模块版本时直接通过镜像站点快速拉取。默认是是https://proxy.golang.org,direct,但是国内无法访问，可以修改为https://goproxy.cn,direct。 *GOPROXT的值以一个英文逗号,分隔Go的模块代理列表，允许设置多个模块代理。 direct是什么? 实际上是一个特殊指示符，用于指示Go回源到模块版本的源地址去抓取(比如GitHub等)，过程如下：当值列表中上一个Go模块代理返回404或410错误时，Go自动尝试列表中下一个，遇到\"direct\"时回源抓取。 GOSUMDB 用于在拉取模块时保证拉取到的模块版本数据未经过篡改。默认值是：sum.golang.org，但是GOSUMMDB可以被Go模块代理所代理，所以不必过度关心这个变量。 GONOPROXY|GONOSUMDN|GOPROVATE 暂时用不到，不用了解，后续用到可以学习。 使用Go Modules 使用go mod init 模块名来指定模块导入路径，后续可以在项目根目录执行go get 第三方包路径导入第三方依赖。 在第一次拉取模块依赖后，还会多出一个go.sum文件。 模块拉取的结果缓存在$GOPATH/pkg/mod和$GOPATH/pkg/sumdb目录下。如果希望清理已缓存的模块版本数据，可执行go clean -modcache命令。 Go Modules下的go get行为 拉取项目依赖时，过程分为三步，分别是finding（发现）、downloading（下载）以及extracting（提取）。注意 不指定版本信息，则由Go modules自行按照内部规则进行选择。 最小版本选择(MVS) 最小版本选择可以理解为”最新非最大“版本选择。举例如下 上图显示了moduleA,B和C分别独立地需要module D和各自需要D的不同版本。我们可以要求go向我们提供所有已存在(打 tag)的版本列表。 可以看到module D 最新最大版本是1.4.2。 如果只有module A，则选择v1.0.6版本即可，如果引入module B,则module D版本会升级到v1.2.0;再次引入module C,则Go将从当前所需版本集合中(v1.0.6 v1.2.0 v1.3.2)选择最新版本v1.3.2, 最后如果删除module C ，Go会将项目锁定到module D 的版本v1.3.2上。降级到版本v1.2.0将是一个更大的更改，而Go知道版本v1.3.2可以正常并稳定运行，因此版本v1.3.2仍然是module D的\"最新但非最大\"版本。 参考博客：go modules 讲解、最小版本选择、go modules讲解2 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:8:2","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"九、反射 ","date":"2021-09-03","objectID":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/:9:0","tags":["Golang"],"title":"Golang基础语法细节","uri":"/posts/%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%E7%BB%86%E8%8A%82/"},{"categories":["Golang学习"],"content":"Go语言实现简单的博客系统笔记记录。","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"基础准备 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:1:0","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"1、热加载 air是Go语言的热加载工具，它可以监听文件或目录的变化，自动编译，重启程序。大大提高开发期的工作效率。 安装使用air工具 在项目的根目录下使用命令go get -u github.com/cosmtrek/air进行安装，此时在go.mod文件中会自动生成模块依赖。 注意：在Go Modules第三方依赖管理模式下，使用go get -u 地址来下载安装第三方依赖。 使用air init会在根目录下生成一份配置文件，可以配置项目根目录，临时文件目录，编译和执行的命令等。 使用air命令就可以运行程序，后续会自动编译，启动程序，并监听当前目录中的文件修改。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:1:1","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"2、Web 一些散知识点 http.HandleFunc(\"/\", handler)里传参的/意味着任意路径。 可以通过WriterHeader()来设置响应的状态码。常见的有(StatusNotFound 404:页面没找到等)可以通过文档查看。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:1:2","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"路由和中间件 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:2:0","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"1、路由 ServeMux和Handler Go语言中处理HTTP请求主要跟两个东西有关：ServeMux和Handler。 ServeMux本质上是一个HTTP请求的路由器(或者叫多路复用器，Multiplexor)。他把收到的请求与一组预先定义的URL路径列表做对比，然后在匹配到路径的时候调用关联的处理器（Handler）。 http.ListenAndServe(addr string, handler Handler)中handler通常是nil,此种情况下会使用DefaultServeMux http.ServeMux的对比其他第三方路由优缺点 优点： 标准库意味着随着Go打包安装，无须另行安装 测试充分；稳定、兼容性强 简单、高效 缺点： 缺少web开发常见的特性 在复杂的项目中使用，需要写更多的代码。 常见的第三方路由有HttpRouter、gorilla/mux。HttpRouter是目前速度最快的路由器，且被框架Gin所采用。 路由解析规则 精准匹配指路由只会匹配准确指定的规则。 长度优先匹配一般用在静态路由上（不支持动态元素如正则和URL路径参数），优先匹配字符数较多的规则。 以下面的为例： 使用长度优先匹配规则的http.ServeMux会把除了/about这个匹配的以外的所有URI都是用defaultHandler来处理。 使用精准匹配的gorilla/mux会把以上两个规则精准匹配到两个链接，/为首页，/about为关于，除此之外都是404未找到。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:2:1","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"2、依赖管理Go Modules 弃用GOPATH Go Modules出现的目的之一就是为了解决GOPATH的问题。 在GOPATH时代，Go源码必须放置在GOPATH/src下，抛弃GOPATH的好处就是能下任意地方创建Go项目。另外，GOPATH有非常落后的依赖管理系统。因为在执行go get时无法传达任何版本信息。无法保证所有人的依赖版本都一致。 Go Modules日常使用 初始化 新项目，使用go mod init初始化生成go.mod文件。 Go Proxy 国内访问外网受限，一般需要配合Go Proxy使用，防止go get获取源码包时花费时间过长。安装package的原则是先拉最新的release tag，若无tag则拉最新的commit。 使用go env -w ...来修改Go相关的环境变量。 go.mod 每一次的go get会同时修改go.mod和go.sum文件。查看 go.mod代码： 几个参数： module —– 我们的项目在Go Module里也算一个Module go —– 指定了版本要求，最低1.15 require —– 项目所需依赖 go.sum go.sum文件保存着依赖包的版本和哈希值。直接依赖包、间接依赖包的哈希值都会被保存。 indirect 回到go.mod中，可以看到require区块里有// indirect字样：此标志标明这个依赖包还未被使用，如果在代码的某个地方import到的话，这个标志会自动去除。 go mod tidy命令 此命令做整理依赖使用，执行时会把未使用的module移除掉。 源码包的存放位置 默认源码包存放于GOPATH/pkg/mod中。 清空Go Modules缓存 使用go clean -modcache命令清空本地下载的Go Modules缓存。 下载依赖 默认情况下，执行go run和go build命令时，Go会基于自动go.mod文件自动拉取依赖。Go Module也提供了go mod download命令下载项目所需依赖。 所有Go Module命令 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:2:2","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"3、URI中的斜杠 访问以下两个链接： ocalhost:3000/about localhost:3000/about/ 可以看到有/的链接会报404错误。我们需要在URL进入Gorilla Mux路由解析之前，将后面的/去掉。使用中间件会因为执行顺序的问题，Gorilla Mux会先匹配路由，在执行中间件，故使用中间件依然会返回404。 解决方法很简单，就是写一个函数把Gorilla Mux包起来，在这个函数中我们先对请求做处理，再传给Gorilla Mux解析。但需要注意把首页URL的/排除在外。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:2:3","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"表单提交 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:3:0","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"1、读取表单请求数据 r.ParseForm()由http包提供，从请求中解析请求参数，必须是执行完这段代码，后面使用r.PostForm和r.Form才能读取到数据，否则为空数组。 Form:存储了post、put和get参数，在使用之前需要调用ParseForm方法。 PostForm:存储了post、put参数，在使用之前需要调用ParseForm方法。 如果不想获取所有请求内容，而是逐个获取的话，无需使用r.ParseForm()可直接使用r.FormValue()和r.PostFormValue()方法。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:3:1","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"2、模板文件语法 双层大括号{{}}是默认的模板界定符。用于在HTML模板文件中界定模板语法。模板语法都包含在{{和}}中。 {{.}}语句 {{.}}中的点表示当前对象。当我们传入一个结构体对象时，我们可以使用.来访问结构体的对应字段。同理，当我们传入的变量是map时，也可以在末班文件中通过.根据key来取值。 with关键字 语法如下： 注释 注释，执行时会忽略。可以多行，不能嵌套并且必须紧贴分界符。 变量 还可以在模板中声明变量，用来保存传入模板的数据或其他语句生成的结果。具体语法如下: 其中$variable是变量的名字，在后续的代码中可以使用该变量。 移除空格 有时会不可避免的引入空格或换行符，导致模板最终渲染结果不如预期，这种情况下可以使用移除空格语法。 注意：-要紧挨{{和}}，同时与模板值之间需要使用空格分隔。 条件判断 range遍历 range遍历有两种写法，其中pipeline的值必须是数组、切片、字典或者通道。 修改默认的分界符 Go标准库的模板引擎使用两对花括号作为标识，而许多前端框架（如Vue和AngularJS）也是用两队花括号作为标识符，同时使用会产生冲突，需要修改标识符，演示修改Go语言模板引擎的默认标识符。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:3:2","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"操作数据库 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:4:0","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"1、MySQL驱动 操作MySQL数据库 使用Go操作MySQL等数据库，一般有两种方式： 一是利用database/sql接口，直接在代码里硬编写sql语句 二是利用ORM,具体一点就是GORM,以对象关系映射的方式在抽象地操作数据库。 MySQL驱动使用 选用github.com/go-sql-diver/mysql项目作为数据库驱动。使用go get -u github.com/go-sql-driver/mysql下载驱动。 下载后，在项目中引入： 注意导入MySQL驱动时，在包路径前添加了_,这里我们使用了匿名导入的方式来加载驱动。 为什么需要匿名导入？ 因为引入的是驱动，操作数据库时我们使用的是sql库里的方法，而不会具体使用到github.com/go-sql-driver/mysql包里的方法，当有未使用的包被引入时，Go编译器会停止编译。为了能让编译器正常运行，需要使用匿名导入来加载。 当导入一个数据库驱动后，此驱动会自行初始化(利用init()函数)并注册自己到Golang的database/sql上下文中，随后我们就可以通过database/sql包提供的方法来操作数据库了。 驱动里的init()代码如下： 注意: Go 语言中，为了使用导入的程序包，必须首先对其进行初始化。初始化始终在单个线程中执行，并且以程序包依赖关系的顺序执行。初始化每个包后，会优先自动执行 init() 函数，并且执行优先级高于主函数的执行优先级。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:4:1","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"2、连接数据库 sql.DB连接池 sql.DB结构体是database/sql包封装的一个数据库操作对象，包含了操作数据库的基本方法，通常情况下理解为连接池对象。 一般而言，使用sql.Open()函数便可以初始化并返回一个*sql.DB结构体实例，只需要传入驱动名称及对应的DSN便可。 注意，调用sql.Open()时，并未开始连接数据库，只是为连接数据库做好准备而已。所以一般都会跟一个db.Ping()来检测连接状态。 连接池配置信息设置 推荐以下设置： SetMaxOpenConns最大连接数 设置连接池最大打开数据库连接数，\u003c=0表示无限制，默认为0。实验表明，在高并发的情况下，将值设为大于 10，可以获得比设置为 1 接近六倍的性能提升。而设置为 10 跟设置为 0（也就是无限制），在高并发的情况下，性能差距不明显。 但需要注意不能超过数据库系统设置的最大连接数。否则会出现MySQL错误： SetMaxIdleConns空闲连接数 设置连接池最大空闲数据库连接数，\u003c=0表示不设置空闲连接数，默认为2。实验表明，在高并发的情况下，将值设为大于 0，可以获得比设置为 0 超过 20 倍的性能提升。 这是因为设置为 0 的情况下，每一个 SQL 连接执行任务以后就销毁掉了，执行新任务时又需要重新建立连接。很明显，重新建立连接是很消耗资源的一个动作。设置空闲连接数，当有新任务进来时，直接使用这些随时待命的连接传输数据，以此达到节约资源，提高执行效率的目的。 SetConnMaxLifetime过期时间 设置连接池里每一个连接的过期时间，过期会自动关闭。理论上来讲，在并发的情况下，此值越小，连接就会越快被关闭，也意味着更多的连接会被创建。设置的值不应该超过 MySQL 的 wait_timeout 设置项（默认情况下是 8 个小时）。 DSN DSN全称是Data Source Name，表示数据库连接源，用于定义数据库的连接信息，不同数据库的DSN格式不同。可以使用mysql.Config创建MySQL的连接信息： ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:4:2","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"3、数据库表结构 新建数据库 有两种方式，一种是使用命令行创建数据库，一种是使用可视化工具（NaviCat）。 命令行创建数据库 连接数据库通用格式： 端口默认是3306,主机默认是localhost，如果默认可以不传输，使用命令mysql -u root -p即可认证成功进入命令行模式。 使用命令：CREATE DATABASE goblog CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;创建数据库。编码使用utf8mb4_unicode_ci可以支持存储Emoji,另外支持大小写不敏感(ci是Case Insensitive的缩写)。 建表 使用Exec()来执行创建数据库表结构的语句。一般使用sql.DB()中的Exec()来执行没有返回结果集的SQL语句。例如INSERT，UPDATA，DELETE等语句。语法如下： Exec()方法的第一个返回值实现了sql.Result接口的类型，sql.Result的定义如下： ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:4:3","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"4、插入数据 多变量声明的方式和引入多个包使用import(...)一样。 prepare语句 在数据库安全方面，Prepare语句是防范SQL注入攻击有效且必备的手段，SQL注入的例子请见—-Golang MySQL驱动中的Prepare语句（防止SQL注入）。SQL注入详解 sql.Stmt 当我们执行： 会使用会使用 SQL 连接向 MySQL 服务器发送一次请求，此方法返回一个 *sql.Stmt 指针对象，我们将其赋值到 stmt 变量里。stmt 是 statement 的简写，是声明、陈诉的意思。可以理解为将包含变量占位符 ? 的语句先告知 MySQL 服务器端。 此时的stmt是一个指针变量，会占用SQL连接，我们需要对其进行关闭以释放SQL连接。及时关闭SQL连接很有必要，否则很快就会报错ERROR 1040: Too many connections。 stmt.Exec() Prepare只会生产stmt，真正执行请求需要调用stmt.Exec()。stmt.Exec() 的参数依次对应 db.Prepare() 参数中 SQL 变量占位符 ?。返回一个sql.Result对象。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:4:4","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"5、显示文章 Prepare模式 QueryRow()是可变参数的方法，语法如下： 它的参数可以为一个或者多个。参数只有一个的情况下，我们称之为纯文本模式(易被SQL注入)，多个参数的情况下称之为 Prepare 模式。 之所以称之为 Prepare 模式是因为当多个参数的情况下，QueryRow() 封装了 Prepare 方法的调用，也就是说，下面这段代码： 等同于： 使用 QueryRow()的 Prepare 模式不仅保证了安全性，更能提升可读性。 关于Prepare模式和纯文本模式，需要注意两点： 使用Prepare 模式会发送两个 SQL 请求到 MySQL 服务器上，而纯文本模式只有一个； 在使用路由参数过滤只允许数字的情况下，可以放心使用纯文本模式无需担心 SQL 注入。 Scan（）方法 QueryRow() 会返回一个 sql.Row struct，紧接着我们使用链式调用的方式调用了 sql.Row.Scan() 方法： 需要注意的是，返回的sql.Row是个指针变量，保存有 SQL 连接。当调用 Scan() 时，就会将连接释放。所以在每次 QueryRow 后使用 Scan 是必须的。 极力推荐这种链式调用的方式，养成好习惯以避免掉进 SQL 连接不够用的坑。 ","date":"2021-09-03","objectID":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/:4:5","tags":["Golang","Web"],"title":"Golang实现博客(一)","uri":"/posts/golang%E5%AE%9E%E7%8E%B0%E5%8D%9A%E5%AE%A2%E4%B8%80/"},{"categories":["Golang学习"],"content":"Go语言操作数据知识点总结。","date":"2021-09-03","objectID":"/posts/sql%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/","tags":["Golang","sql"],"title":"Golang操作sql总结","uri":"/posts/sql%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang学习"],"content":"总结Go标准库里sql包的使用方法。 ","date":"2021-09-03","objectID":"/posts/sql%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/:0:0","tags":["Golang","sql"],"title":"Golang操作sql总结","uri":"/posts/sql%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/"},{"categories":["Golang学习"],"content":"Go语言面试题总结。","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Golang学习"],"content":"1、nil切片和空切片 ","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/:1:0","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Golang学习"],"content":"问题 nil切片和空切片指向的地址一样吗？代码会输出什么？ ","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/:1:1","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Golang学习"],"content":"回答 nil切片和空切片指向的地址不一样。nil空切片引用数组指针地址为0（无指向任何实际地址） 空切片的引用数组指针地址是有的，且固定为一个值 两个空切片指向的数组地址一样。 ","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/:1:2","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Golang学习"],"content":"解释 切片的数据结构为如下： nil切片和空切片最大的区别在于指向的数组引用地址是不一样的。 所有的空切片指向的数组引用地址都是一样的。 len,cap和append等功能在nil切片上同样可以正常工作。 如果非常在意性能和内存使用情况，初始化一个空切片可能不如使用nil切片理想。 ","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/:1:3","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Golang学习"],"content":"2、字符串转成byte数组，会发生内存拷贝吗？ ","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/:2:0","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Golang学习"],"content":"回答 字符串转成切片，会产生拷贝。严格来说，只要是发生类型强转都会产生内存拷贝。 有没有什么办法可以在字符串转成切片的时候不用发生拷贝呢？ ","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/:2:1","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["Golang学习"],"content":"解释 StringHeader是字符串在go底层结构 SliceHeader是切片在go底层结构 如果想要在底层转换二者，只需要把StringHeader的地址强转成SliceHeader就行。golang有一个很强的包叫unsafe。 unsafe.Pointer(\u0026a)方法可以得到变量a的地址。 (*reflect.StringHeader)(unsafe.Pointer(\u0026a))可以把字符串a转成底层结构的形式。 (*[]byte)(unsafe.pointer(\u0026ssh))可以把ssh底层结构体转成byte的切片指针。 再通过*转成指针指向的实际内容。 ","date":"2021-09-03","objectID":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/:2:2","tags":["Golang","面试"],"title":"Golang面试题","uri":"/posts/golang%E9%9D%A2%E8%AF%95%E9%A2%98/"},{"categories":["算法学习"],"content":"算法学习之栈与队列学习，主要学习栈和队列相互实现以及LeetCode经典题目学习。","date":"2021-09-03","objectID":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/","tags":["栈和队列","算法学习"],"title":"栈和队列","uri":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["算法学习"],"content":"队列是一种先进先出的数据结构，栈是一种先进后出的数据结构。这两种数据结构底层都是数组或者链表实现的，只是API限定了它们的特性。 ","date":"2021-09-03","objectID":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:0:0","tags":["栈和队列","算法学习"],"title":"栈和队列","uri":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["算法学习"],"content":"栈实现队列 队列API如下： ","date":"2021-09-03","objectID":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:1:0","tags":["栈和队列","算法学习"],"title":"栈和队列","uri":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["算法学习"],"content":"思路 使用两个栈s1,s2就能实现一个队列的功能。 当调用push让元素入队时，只要把元素压入s1即可，例如push进三个元素分别是1、2、3，底层结构如下： 当调用pop或则peek时，按道理队头元素应该是1，但是在s1中1被压在栈底，就需要s2起到一个中转作用。 当s2为空时，可以把s1的所有元素取出再添加进s2，这时候s2中元素就是先进先出顺序了。 最后如何判断队列是否为空呢？如果两个栈都为空的话，说明队列为空。 ","date":"2021-09-03","objectID":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:1:1","tags":["栈和队列","算法学习"],"title":"栈和队列","uri":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["算法学习"],"content":"代码实现 ","date":"2021-09-03","objectID":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:1:2","tags":["栈和队列","算法学习"],"title":"栈和队列","uri":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["算法学习"],"content":"时间复杂度分析 其他操作都是O(1)。只有peek操作，调用它时可能触发while循环，遮掩的话时间复杂度是O(N)。由于pop操作调用了peek,故时间复杂度和peek相同。故最坏时间复杂度是O(N),均摊时间复杂度是O(1)。 ","date":"2021-09-03","objectID":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:1:3","tags":["栈和队列","算法学习"],"title":"栈和队列","uri":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["算法学习"],"content":"用队列实现栈 ","date":"2021-09-03","objectID":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/:2:0","tags":["栈和队列","算法学习"],"title":"栈和队列","uri":"/posts/%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"},{"categories":["算法学习"],"content":"算法学习之链表学习，主要包括链表的一些常见LeetCode题目学习。","date":"2021-09-03","objectID":"/posts/%E9%93%BE%E8%A1%A8/","tags":["链表","算法学习"],"title":"链表","uri":"/posts/%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"反转链表 考虑先用递归实现。迭代思路虽然简单，但细节问题很多。 ","date":"2021-09-03","objectID":"/posts/%E9%93%BE%E8%A1%A8/:1:0","tags":["链表","算法学习"],"title":"链表","uri":"/posts/%E9%93%BE%E8%A1%A8/"},{"categories":["算法学习"],"content":"递归反转整个链表 代码如下： 对于递归算法，最重要的是明确递归函数的定义。reverseList函数的定义是：输入一个节点head,将以head为起点的链表反转，并返回反转之后的头结点。 代码解释 对于如下的链表 输入reverseList(head)后，会在last := reverseList(head.Next)进行递归。执行完后，整个链表应该如下： 接下来的代码进行了如下操作，最后返回last。 这样整个链表就反转过来了。 注意： 1、递归函数需要base case,也就是下面的代码。 2、当链表递归反转之后，新的头结点是last,而之前的head变成了最后一个节点，因此需要指向nil。 ","date":"2021-09-03","objectID":"/posts/%E9%93%BE%E8%A1%A8/:1:1","tags":["链表","算法学习"],"title":"链表","uri":"/posts/%E9%93%BE%E8%A1%A8/"},{"categories":null,"content":"博主相关 ","date":"2021-09-01","objectID":"/about/:1:0","tags":null,"title":"关于NarcissusBlog","uri":"/about/"},{"categories":null,"content":"近况 硕士在读，目前正在国内某末流985给导师打工搬砖，码农界萌新。 ","date":"2021-09-01","objectID":"/about/:1:1","tags":null,"title":"关于NarcissusBlog","uri":"/about/"},{"categories":null,"content":"技能 正在努力开发中 ","date":"2021-09-01","objectID":"/about/:1:2","tags":null,"title":"关于NarcissusBlog","uri":"/about/"},{"categories":null,"content":"站点相关 NarcissusBlog 是由博主建立的简洁、优雅且高效的静态笔记博客。方便记录博主使用markdown格式编写的笔记并快速生成前端博客页面。 ","date":"2021-09-01","objectID":"/about/:2:0","tags":null,"title":"关于NarcissusBlog","uri":"/about/"},{"categories":null,"content":"站点相关技术 使用 Hugo 和 LoveIt主题。站中所有图片都采用阿里云OSS对象存储外链，部署到GitHub pages，绑定到个人域名。 ","date":"2021-09-01","objectID":"/about/:2:1","tags":null,"title":"关于NarcissusBlog","uri":"/about/"}]